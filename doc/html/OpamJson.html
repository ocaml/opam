<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="OpamFormula.html">
<link rel="next" href="OpamMisc.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="OpamAction" rel="Chapter" href="OpamAction.html">
<link title="OpamArg" rel="Chapter" href="OpamArg.html">
<link title="OpamClient" rel="Chapter" href="OpamClient.html">
<link title="OpamConfigCommand" rel="Chapter" href="OpamConfigCommand.html">
<link title="OpamPinCommand" rel="Chapter" href="OpamPinCommand.html">
<link title="OpamRepositoryCommand" rel="Chapter" href="OpamRepositoryCommand.html">
<link title="OpamSolution" rel="Chapter" href="OpamSolution.html">
<link title="OpamState" rel="Chapter" href="OpamState.html">
<link title="OpamSwitchCommand" rel="Chapter" href="OpamSwitchCommand.html">
<link title="OpamCompiler" rel="Chapter" href="OpamCompiler.html">
<link title="OpamFile" rel="Chapter" href="OpamFile.html">
<link title="OpamFilename" rel="Chapter" href="OpamFilename.html">
<link title="OpamFilter" rel="Chapter" href="OpamFilter.html">
<link title="OpamFormat" rel="Chapter" href="OpamFormat.html">
<link title="OpamFormula" rel="Chapter" href="OpamFormula.html">
<link title="OpamJson" rel="Chapter" href="OpamJson.html">
<link title="OpamMisc" rel="Chapter" href="OpamMisc.html">
<link title="OpamPackage" rel="Chapter" href="OpamPackage.html">
<link title="OpamParallel" rel="Chapter" href="OpamParallel.html">
<link title="OpamPath" rel="Chapter" href="OpamPath.html">
<link title="OpamProcess" rel="Chapter" href="OpamProcess.html">
<link title="OpamRepository" rel="Chapter" href="OpamRepository.html">
<link title="OpamRepositoryName" rel="Chapter" href="OpamRepositoryName.html">
<link title="OpamSwitch" rel="Chapter" href="OpamSwitch.html">
<link title="OpamSystem" rel="Chapter" href="OpamSystem.html">
<link title="OpamTypes" rel="Chapter" href="OpamTypes.html">
<link title="OpamVariable" rel="Chapter" href="OpamVariable.html">
<link title="OpamVersion" rel="Chapter" href="OpamVersion.html">
<link title="OpamDarcs" rel="Chapter" href="OpamDarcs.html">
<link title="OpamGit" rel="Chapter" href="OpamGit.html">
<link title="OpamHTTP" rel="Chapter" href="OpamHTTP.html">
<link title="OpamHg" rel="Chapter" href="OpamHg.html">
<link title="OpamLocal" rel="Chapter" href="OpamLocal.html">
<link title="OpamVCS" rel="Chapter" href="OpamVCS.html">
<link title="Opam_mk_repo" rel="Chapter" href="Opam_mk_repo.html">
<link title="Opam_repo_check" rel="Chapter" href="Opam_repo_check.html">
<link title="Opam_stats" rel="Chapter" href="Opam_stats.html">
<link title="OpamCudf" rel="Chapter" href="OpamCudf.html">
<link title="OpamHeuristic" rel="Chapter" href="OpamHeuristic.html">
<link title="OpamSolver" rel="Chapter" href="OpamSolver.html"><link title="JSON data model" rel="Section" href="#datamodel">
<link title="Decode" rel="Section" href="#decode">
<link title="Encode" rel="Section" href="#encode">
<link title="Manual sources and destinations" rel="Section" href="#manual">
<link title="Uncut codec" rel="Section" href="#uncut">
<link title="Limitations" rel="Section" href="#limitations">
<link title="Error recovery" rel="Section" href="#errorrecovery">
<link title="Examples" rel="Section" href="#examples">
<link title="Decode" rel="Subsection" href="#2_Decode">
<link title="Encode" rel="Subsection" href="#2_Encode">
<link title="Trip" rel="Subsection" href="#filter">
<link title="Member selection" rel="Subsection" href="#memsel">
<link title="Generic JSON representation" rel="Subsection" href="#tree">
<title>OpamJson</title>
</head>
<body>
<div class="navbar"><a class="pre" href="OpamFormula.html" title="OpamFormula">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="OpamMisc.html" title="OpamMisc">Next</a>
</div>
<h1>Module <a href="type_OpamJson.html">OpamJson</a></h1>

<pre><span class="keyword">module</span> OpamJson: <code class="code">sig</code> <a href="OpamJson.html">..</a> <code class="code">end</code></pre><div class="info module top">
Non-blocking streaming JSON codec.
<p>

    <code class="code">Jsonm</code> is a non-blocking streaming codec to
    <a href="OpamJson.html#decode">decode</a> and <a href="OpamJson.html#encode">encode</a> the
    <a href="http://tools.ietf.org/html/rfc4627">JSON</a> data format. It can
    process JSON text without blocking on IO and without a complete
    in-memory representation of the data.
<p>

    The <a href="OpamJson.Uncut.html">uncut codec</a> also processes whitespace and
    (non-standard) JSON with JavaScript comments.
<p>

    Consult the <a href="OpamJson.html#datamodel">data model</a>, <a href="OpamJson.html#limitations">limitations</a>
    and <a href="OpamJson.html#examples">examples</a> of use.
<p>

    <em>Version 0.9.1 - Daniel BÃ¼nzli &lt;daniel.buenzli at erratique.ch&gt; </em>
    <h3 id="3_References">References</h3>
    <ul>
<li>D. Crockford
    <em><a href="http://tools.ietf.org/html/rfc4627">JSON The application/json Media
    Type for JavaScript Object Notation (JSON)</a></em>, 2006.</li>
</ul>
<br>
</div>
<hr width="100%">
<br>
<h1 id="datamodel">JSON data model</h1><br>

<pre><span id="TYPElexeme"><span class="keyword">type</span> <code class="type"></code>lexeme</span> = <code class="type">[ `Ae<br>       | `As<br>       | `Bool of bool<br>       | `Float of float<br>       | `Name of string<br>       | `Null<br>       | `Oe<br>       | `Os<br>       | `String of string ]</code> </pre>
<div class="info ">
The type for JSON lexemes. <code class="code">`As</code> and <code class="code">`Ae</code>
    start and end arrays and <code class="code">`Os</code> and <code class="code">`Oe</code> start
    and end objects. <code class="code">`Name</code> is for the member names of objects.
<p>

    A <em>well-formed</em> sequence of lexemes belongs to the language of
    the <code class="code">json</code> grammar:
<pre class="codepre"><code class="code">  json = object / array
object = `Os *member `Oe
member = (`Name s) value
 array = `As *value `Ae
 value = `Null / `Bool b / `Float f / `String s / object / array
</code></pre>
    A <a href="OpamJson.html#decode">decoder</a> returns only well-formed sequences of
    lexemes or <code class="code">`Error</code>s are returned. The
    <a href="http://tools.ietf.org/html/rfc3629">UTF-8</a>,
    <a href="http://tools.ietf.org/html/rfc2781">UTF-16</a>, UTF-16LE and
    UTF-16BE encoding schemes are supported.  The strings of decoded
    <code class="code">`Name</code> and <code class="code">`String</code> lexemes are however always UTF-8 encoded. In
    these strings, characters originally escaped in the input are in
    their unescaped representation.
<p>

    An <a href="OpamJson.html#encode">encoder</a> accepts only well-formed sequences
    of lexemes or <code class="code">Invalid_argument</code> is raised. Only the UTF-8
    encoding scheme is supported. The strings of encoded <code class="code">`Name</code> and
    <code class="code">`String</code> lexemes are assumed to be immutable and must be UTF-8
    encoded, this is <b>not</b> checked by the module. In these strings,
    the delimiter characters <code class="code">U+0022</code> and <code class="code">U+005C</code> (<code class="code">'"'</code>, <code class="code">'\'</code>)
    aswell as the control characters <code class="code">U+0000-U+001F</code> are automatically
    escaped by the encoders, as mandated by the standard.<br>
</div>


<pre><span id="VALpp_lexeme"><span class="keyword">val</span> pp_lexeme</span> : <code class="type">Format.formatter -> [< <a href="OpamJson.html#TYPElexeme">lexeme</a> ] -> unit</code></pre><div class="info ">
<code class="code">pp_lexeme ppf l</code> prints a unspecified non-JSON representation of <code class="code">l</code>
    on <code class="code">ppf</code>.<br>
</div>
<br>
<h1 id="decode">Decode</h1><br>

<pre><span id="TYPEerror"><span class="keyword">type</span> <code class="type"></code>error</span> = <code class="type">[ `Expected of<br>           [ `Aval of bool<br>           | `Comment<br>           | `Eoi<br>           | `Json<br>           | `Name<br>           | `Name_sep<br>           | `Omem of bool<br>           | `Value ]<br>       | `Illegal_BOM<br>       | `Illegal_bytes of string<br>       | `Illegal_escape of<br>           [ `Lone_hi_surrogate of int<br>           | `Lone_lo_surrogate of int<br>           | `Not_esc_uchar of int<br>           | `Not_hex_uchar of int<br>           | `Not_lo_surrogate of int ]<br>       | `Illegal_literal of string<br>       | `Illegal_number of string<br>       | `Illegal_string_uchar of int<br>       | `Unclosed of [ `As | `Comment | `Os | `String ] ]</code> </pre>

<br>
The type for decoding errors.<br>

<pre><span id="VALpp_error"><span class="keyword">val</span> pp_error</span> : <code class="type">Format.formatter -> [< <a href="OpamJson.html#TYPEerror">error</a> ] -> unit</code></pre><div class="info ">
<code class="code">pp_error e</code> prints an unspecified UTF-8 representation of <code class="code">e</code> on <code class="code">ppf</code>.<br>
</div>

<pre><span id="TYPEencoding"><span class="keyword">type</span> <code class="type"></code>encoding</span> = <code class="type">[ `UTF_16 | `UTF_16BE | `UTF_16LE | `UTF_8 ]</code> </pre>
<div class="info ">
The type for Unicode encoding schemes.<br>
</div>


<pre><span id="TYPEsrc"><span class="keyword">type</span> <code class="type"></code>src</span> = <code class="type">[ `Channel of Pervasives.in_channel | `Manual | `String of string ]</code> </pre>
<div class="info ">
The type for input sources. With a <code class="code">`Manual</code> source the client
    must provide input with <a href="OpamJson.Manual.html#VALsrc"><code class="code">OpamJson.Manual.src</code></a>.<br>
</div>


<pre><span id="TYPEdecoder"><span class="keyword">type</span> <code class="type"></code>decoder</span> </pre>
<div class="info ">
The type for JSON decoders.<br>
</div>


<pre><span id="VALdecoder"><span class="keyword">val</span> decoder</span> : <code class="type">?encoding:[< <a href="OpamJson.html#TYPEencoding">encoding</a> ] -> [< <a href="OpamJson.html#TYPEsrc">src</a> ] -> <a href="OpamJson.html#TYPEdecoder">decoder</a></code></pre><div class="info ">
<code class="code">decoder encoding src</code> is a JSON decoder that inputs from <code class="code">src</code>.
    <code class="code">encoding</code> specifies the character encoding of the data. If unspecified
    the encoding is guessed as
    <a href="http://tools.ietf.org/html/rfc4627#section-3">suggested</a> by
    the standard.<br>
</div>

<pre><span id="VALdecode"><span class="keyword">val</span> decode</span> : <code class="type"><a href="OpamJson.html#TYPEdecoder">decoder</a> -><br>       [> `Await | `End | `Error of <a href="OpamJson.html#TYPEerror">error</a> | `Lexeme of <a href="OpamJson.html#TYPElexeme">lexeme</a> ]</code></pre><div class="info ">
<code class="code">decode d</code> is:
    <ul>
<li><code class="code">`Await</code> if <code class="code">d</code> has a <code class="code">`Manual</code> source and awaits for more input.
       The client must use <a href="OpamJson.Manual.html#VALsrc"><code class="code">OpamJson.Manual.src</code></a> to provide it.</li>
<li><code class="code">`Lexeme l</code> if a lexeme <code class="code">l</code> was decoded.</li>
<li><code class="code">`End</code> if the end of input was reached.</li>
<li><code class="code">`Error e</code> if a decoding error occured. If the client is interested
       in a best-effort decoding it can still continue to decode
       after an error (see <a href="OpamJson.html#errorrecovery"><i>Error recovery</i></a>) although the resulting sequence
       of <code class="code">`Lexeme</code>s is undefined and may not be well-formed.</li>
</ul>

<p>

    The <a href="OpamJson.Uncut.html#VALpp_decode"><code class="code">OpamJson.Uncut.pp_decode</code></a> function can be used to inspect decode results.
<p>

    <b>Note.</b> Repeated invocation always eventually returns <code class="code">`End</code>, even
    in case of errors.<br>
</div>

<pre><span id="VALdecoded_range"><span class="keyword">val</span> decoded_range</span> : <code class="type"><a href="OpamJson.html#TYPEdecoder">decoder</a> -> (int * int) * (int * int)</code></pre><div class="info ">
<code class="code">decoded_range d</code> is the range of characters spanning the last
    <code class="code">`Lexeme</code> or <code class="code">`Error</code> (or <code class="code">`White</code> or <code class="code">`Comment</code> for an
    <a href="OpamJson.Uncut.html#VALdecode"><code class="code">OpamJson.Uncut.decode</code></a>) decoded by <code class="code">d</code>.  A pair of line and column numbers
    respectively one and zero based.<br>
</div>

<pre><span id="VALdecoder_encoding"><span class="keyword">val</span> decoder_encoding</span> : <code class="type"><a href="OpamJson.html#TYPEdecoder">decoder</a> -> <a href="OpamJson.html#TYPEencoding">encoding</a></code></pre><div class="info ">
<code class="code">decoder_encoding d</code> is <code class="code">d</code>'s encoding.
<p>

    <b>Warning.</b> If the decoder guesses the encoding, rely on this
    value only after the first <code class="code">`Lexeme</code> was decoded.<br>
</div>

<pre><span id="VALdecoder_src"><span class="keyword">val</span> decoder_src</span> : <code class="type"><a href="OpamJson.html#TYPEdecoder">decoder</a> -> <a href="OpamJson.html#TYPEsrc">src</a></code></pre><div class="info ">
<code class="code">decoder_src d</code> is <code class="code">d</code>'s input source.<br>
</div>
<br>
<h1 id="encode">Encode</h1><br>

<pre><span id="TYPEdst"><span class="keyword">type</span> <code class="type"></code>dst</span> = <code class="type">[ `Buffer of Buffer.t | `Channel of Pervasives.out_channel | `Manual ]</code> </pre>
<div class="info ">
The type for output destinations. With a <code class="code">`Manual</code> destination the
    client must provide output storage with <a href="OpamJson.Manual.html#VALdst"><code class="code">OpamJson.Manual.dst</code></a>.<br>
</div>


<pre><span id="TYPEencoder"><span class="keyword">type</span> <code class="type"></code>encoder</span> </pre>
<div class="info ">
The type for JSON encoders.<br>
</div>


<pre><span id="VALencoder"><span class="keyword">val</span> encoder</span> : <code class="type">?minify:bool -> [< <a href="OpamJson.html#TYPEdst">dst</a> ] -> <a href="OpamJson.html#TYPEencoder">encoder</a></code></pre><div class="info ">
<code class="code">encoder minify dst</code> is an encoder that outputs to <code class="code">dst</code>. If
    <code class="code">minify</code> is <code class="code">true</code> (default) the output is made as compact as
    possible, otherwise the output is indented. If you want better
    control on whitespace use <code class="code">minify = true</code> and <a href="OpamJson.Uncut.html#VALencode"><code class="code">OpamJson.Uncut.encode</code></a>.<br>
</div>

<pre><span id="VALencode"><span class="keyword">val</span> encode</span> : <code class="type"><a href="OpamJson.html#TYPEencoder">encoder</a> -><br>       [< `Await | `End | `Lexeme of <a href="OpamJson.html#TYPElexeme">lexeme</a> ] -> [ `Ok | `Partial ]</code></pre><div class="info ">
<code class="code">encode e v</code> is:
    <ul>
<li><code class="code">`Partial</code> iff <code class="code">e</code> has a <code class="code">`Manual</code> destination and needs more
       output storage. The client must use <a href="OpamJson.Manual.html#VALdst"><code class="code">OpamJson.Manual.dst</code></a> to provide
       a new buffer and then call <a href="OpamJson.html#VALencode"><code class="code">OpamJson.encode</code></a> with <code class="code">`Await</code> until <code class="code">`Ok</code>
       is returned.</li>
<li><code class="code">`Ok</code> when the encoder is ready to encode a new <code class="code">`Lexeme</code>
       or <code class="code">`End</code>.</li>
</ul>

    For <code class="code">`Manual</code> destinations, encoding <code class="code">`End</code> always returns <code class="code">`Partial</code>,
    the client should as usual use <a href="OpamJson.Manual.html#VALdst"><code class="code">OpamJson.Manual.dst</code></a> and continue with <code class="code">`Await</code>
    until <code class="code">`Ok</code> is returned at which point <a href="OpamJson.Manual.html#VALdst_rem"><code class="code">OpamJson.Manual.dst_rem</code></a> <code class="code">e</code> is guaranteed
    to be the size of the last provided buffer (i.e. nothing was written).
<p>

    <b>Raises.</b> <code class="code">Invalid_argument</code> if a non <a href="OpamJson.html#datamodel">well-formed</a>
    sequence of lexemes is encoded or if <code class="code">`Lexeme</code> or <code class="code">`End</code> is
    encoded after a <code class="code">`Partial</code> encode.<br>
</div>

<pre><span id="VALencoder_dst"><span class="keyword">val</span> encoder_dst</span> : <code class="type"><a href="OpamJson.html#TYPEencoder">encoder</a> -> <a href="OpamJson.html#TYPEdst">dst</a></code></pre><div class="info ">
<code class="code">encoder_dst e</code> is <code class="code">e</code>'s output destination.<br>
</div>

<pre><span id="VALencoder_minify"><span class="keyword">val</span> encoder_minify</span> : <code class="type"><a href="OpamJson.html#TYPEencoder">encoder</a> -> bool</code></pre><div class="info ">
<code class="code">encoder_minify e</code> is <code class="code">true</code> if <code class="code">e</code>'s output is minified.<br>
</div>
<br>
<h1 id="manual">Manual sources and destinations</h1><br>

<pre><span class="keyword">module</span> <a href="OpamJson.Manual.html">Manual</a>: <code class="code">sig</code> <a href="OpamJson.Manual.html">..</a> <code class="code">end</code></pre><div class="info">
Manual input sources and output destinations.
</div>
<br>
<h1 id="uncut">Uncut codec</h1><br>

<pre><span class="keyword">module</span> <a href="OpamJson.Uncut.html">Uncut</a>: <code class="code">sig</code> <a href="OpamJson.Uncut.html">..</a> <code class="code">end</code></pre><div class="info">
Codec with comments and whitespace.
</div>
<br>
<h1 id="limitations">Limitations</h1>
<p>

    <h2 id="2_Decode">Decode</h2>
<p>

    Decoders parse valid JSON with the following limitations:
    <ul>
<li>JSON numbers are represented with OCaml <code class="code">float</code> values.
       This means that it can only represent integers exactly
       in the in the interval [-2<sup class="superscript">53</sup>;2<sup class="superscript">53</sup>]. This is equivalent
       to the contraints JavaScript has.</li>
<li>A superset of JSON numbers is parsed. After having seen a minus
       or a digit, including zero, <code class="code">Pervasives.float_of_string</code>, is
       used. In particular this parses number with leading zeros, which are
       specifically prohibited by the standard.</li>
<li>Strings returned by <code class="code">`String</code>, <code class="code">`Name</code>, <code class="code">`White</code> and <code class="code">`Comment</code>
       are limited by <code class="code">Sys.max_string_length</code>.  There is no built-in
       protection against the fact that the internal OCaml <code class="code">Buffer.t</code>
       value may raise <code class="code">Failure</code> on <code class="code">Jsonm.decode</code>. This should
       however only be a problem on 32-bits platforms if your
       strings are greater than 16Mo.</li>
</ul>

<p>

    Position tracking assumes that each decoded Unicode scalar value
    has a column width of 1. The same assumption may not be made by
    the display program (e.g. for <code class="code">emacs</code>' compilation mode you need
    to set <code class="code">compilation-error-screen-columns</code> to <code class="code">nil</code>).
<p>

    The newlines LF (<code class="code">U+000A</code>), CR (<code class="code">U+000D</code>), and CRLF are all normalized
    to LF internally. This may have an impact in some corner <code class="code">`Error</code>
    cases. For example the invalid escape sequence <code class="code">&lt;U+005C,U+000D&gt;</code> in
    a string will be reported as being <code class="code">`Illegal_escape (`Not_esc_uchar
    0x000A)</code>.
<p>

    <h2 id="2_Encode">Encode</h2>
<p>

    Encoders produce valid JSON provided the <em>client</em> ensures that
    the following holds.
    <ul>
<li>All the strings given to the encoder must be valid UTF-8 and immutable.
       Characters that need to be escaped are automatically escaped by <code class="code">Jsonm</code>.</li>
<li><code class="code">`Float</code> lexemes must not be, <code class="code">Pervasives.nan</code>,
       <code class="code">Pervasives.infinity</code> or <code class="code">Pervasives.neg_infinity</code>. They
       are encoded with the format string <code class="code">"%.16g"</code>, this allows
       to roundtrip all the integers that can be precisely represented
       in OCaml <code class="code">float</code> values, i.e. the integers in the interval
       [-2<sup class="superscript">53</sup>;2<sup class="superscript">53</sup>]. This is equivalent to the constraints
       JavaScript has.</li>
<li>If the <a href="OpamJson.Uncut.html">uncut</a> codec is used <code class="code">`White</code> must be made
       of <a href="OpamJson.Uncut.html#uncutdatamodel">JSON whitespace</a> and <code class="code">`Comment</code>
       must never be encoded.</li>
</ul>
<br>
<br>
<h1 id="errorrecovery">Error recovery</h1>
<p>

    After a decoding error, if best-effort decoding is performed. The following
    happens before continuing:
    <ul>
<li><code class="code">`Illegal_BOM</code>, the initial
       <a href="http://unicode.org/glossary/#byte_order_mark">BOM</a> is skipped.</li>
<li><code class="code">`Illegal_bytes</code>, <code class="code">`Illegal_escape</code>, <code class="code">`Illegal_string_uchar</code>, a
       Unicode
       <a href="http://unicode.org/glossary/#replacement_character">replacement
       character</a> (<code class="code">U+FFFD</code>) is substituted to the illegal sequence.</li>
<li><code class="code">`Illegal_literal</code>, <code class="code">`Illegal_number</code> the corresponding
       <code class="code">`Lexeme</code> is skipped.</li>
<li><code class="code">`Expected r</code>, input is discarded until a synchronyzing lexeme
       that depends on <code class="code">r</code> is found.</li>
<li><code class="code">`Unclosed</code>, the end of input is reached, further decodes will be
       <code class="code">`End</code></li>
</ul>
<br>
<br>
<h1 id="examples">Examples</h1>
<p>

    <h2 id="filter">Trip</h2>
<p>

    The result of <code class="code">trip src dst</code> has the JSON from <code class="code">src</code> written on <code class="code">dst</code>.
<pre class="codepre"><code class="code">let trip ?encoding ?minify
    (src : [`Channel of in_channel | `String of string])
    (dst : [`Channel of out_channel | `Buffer of Buffer.t])
  =
  let rec loop d e = match Jsonm.decode d with
  | `Lexeme _ as v -&gt; ignore (Jsonm.encode e v); loop d e
  | `End -&gt; ignore (Jsonm.encode e `End); `Ok
  | `Error err -&gt; `Error (Jsonm.decoded_range d, err)
  | `Await -&gt; assert false
  in
  let d = Jsonm.decoder ?encoding src in
  let e = Jsonm.encoder ?minify dst in
  loop d e
</code></pre>
    Using the <code class="code">`Manual</code> interface, <code class="code">trip_fd</code> does the same but between Unix
    file descriptors.
<pre class="codepre"><code class="code">let trip_fd ?encoding ?minify
    (fdi : Unix.file_descr)
    (fdo : Unix.file_descr)
  =
  let rec encode fd s e v = match Jsonm.encode e v with `Ok -&gt; ()
  | `Partial -&gt;
      let rec unix_write fd s j l =
        let rec write fd s j l = try Unix.single_write fd s j l with
        | Unix.Unix_error (Unix.EINTR, _, _) -&gt; write fd s j l
        in
        let wc = write fd s j l in
        if wc &lt; l then unix_write fd s (j + wc) (l - wc) else ()
      in
      unix_write fd s 0 (String.length s - Jsonm.Manual.dst_rem e);
      Jsonm.Manual.dst e s 0 (String.length s);
      encode fd s e `Await
  in
  let rec loop fdi fdo ds es d e = match Jsonm.decode d with
  | `Lexeme _ as v -&gt; encode fdo es e v; loop fdi fdo ds es d e
  | `End -&gt; encode fdo es e `End; `Ok
  | `Error err -&gt; `Error (Jsonm.decoded_range d, err)
  | `Await -&gt;
      let rec unix_read fd s j l = try Unix.read fd s j l with
      | Unix.Unix_error (Unix.EINTR, _, _) -&gt; unix_read fd s j l
      in
      let rc = unix_read fdi ds 0 (String.length ds) in
      Jsonm.Manual.src d ds 0 rc; loop fdi fdo ds es d e
  in
  let ds = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let es = String.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let d = Jsonm.decoder ?encoding `Manual in
  let e = Jsonm.encoder ?minify `Manual in
  Jsonm.Manual.dst e es 0 (String.length es);
  loop fdi fdo ds es d e
</code></pre>
    <h2 id="memsel">Member selection</h2>
<p>

    The result of <code class="code">memsel names src</code> is the list of string values of
    members of <code class="code">src</code> that have their name in <code class="code">names</code>. In this example,
    decoding errors are silently ignored.
<pre class="codepre"><code class="code">let memsel ?encoding names
    (src : [`Channel of in_channel | `String of string])
  =
  let rec loop acc names d = match Jsonm.decode d with
  | `Lexeme (`Name n) when List.mem n names -&gt;
      begin match Jsonm.decode d with
      | `Lexeme (`String s) -&gt; loop (s :: acc) names d
      | _ -&gt; loop acc names d
      end
  | `Lexeme _ | `Error _ -&gt; loop acc names d
  | `End -&gt; List.rev acc
  | `Await -&gt; assert false
  in
  loop [] names (Jsonm.decoder ?encoding src)
</code></pre>
<p>

    <h2 id="tree">Generic JSON representation</h2>
<p>

    A generic OCaml representation of JSON text is the following one.
<pre class="codepre"><code class="code">type json =
  [ `Null | `Bool of bool | `Float of float| `String of string
  | `A of json list | `O of (string * json) list ]
</code></pre>
    The result of <code class="code">json_of_src src</code> is the JSON text from <code class="code">src</code> in this
    representation. The function is tail recursive.
<pre class="codepre"><code class="code">exception Escape of ((int * int) * (int * int)) * Jsonm.error

let json_of_src ?encoding
    (src : [`Channel of in_channel | `String of string])
  =
  let dec d = match Jsonm.decode d with
  | `Lexeme l -&gt; l
  | `Error e -&gt; raise (Escape (Jsonm.decoded_range d, e))
  | `End | `Await -&gt; assert false
  in
  let rec value v k d = match v with
  | `Os -&gt; obj [] k d  | `As -&gt; arr [] k d
  | `Null | `Bool _ | `String _ | `Float _ as v -&gt; k v d
  | _ -&gt; assert false
  and arr vs k d = match dec d with
  | `Ae -&gt; k (`A (List.rev vs)) d
  | v -&gt; value v (fun v -&gt; arr (v :: vs) k) d
  and obj ms k d = match dec d with
  | `Oe -&gt; k (`O (List.rev ms)) d
  | `Name n -&gt; value (dec d) (fun v -&gt; obj ((n, v) :: ms) k) d
  | _ -&gt; assert false
  in
  let d = Jsonm.decoder ?encoding src in
  try `JSON (value (dec d) (fun v _ -&gt; v) d) with
  | Escape (r, e) -&gt; `Error (r, e)
</code></pre>
    The result of <code class="code">json_to_dst dst json</code> has the JSON text <code class="code">json</code> written
    on <code class="code">dst</code>. The function is tail recursive.
<pre class="codepre"><code class="code">let json_to_dst ~minify
    (dst : [`Channel of out_channel | `Buffer of Buffer.t ])
    (json : json)
  =
  let enc e l = ignore (Jsonm.encode e (`Lexeme l)) in
  let rec value v k e = match v with
  | `A vs -&gt; arr vs k e
  | `O ms -&gt; obj ms k e
  | `Null | `Bool _ | `Float _ | `String _ as v -&gt; enc e v; k e
  and arr vs k e = enc e `As; arr_vs vs k e
  and arr_vs vs k e = match vs with
  | v :: vs' -&gt; value v (arr_vs vs' k) e
  | [] -&gt; enc e `Ae; k e
  and obj ms k e = enc e `Os; obj_ms ms k e
  and obj_ms ms k e = match ms with
  | (n, v) :: ms -&gt; enc e (`Name n); value v (obj_ms ms k) e
  | [] -&gt; enc e `Oe; k e
  in
  let e = Jsonm.encoder ~minify dst in
  let finish e = ignore (Jsonm.encode e `End) in
  match json with `A _ | `O _ as json -&gt; value json finish e
  | _ -&gt; invalid_arg "invalid json text"
</code></pre><br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type">[ `A of <a href="OpamJson.html#TYPEt">t</a> list<br>       | `Bool of bool<br>       | `Float of float<br>       | `Null<br>       | `O of (string * <a href="OpamJson.html#TYPEt">t</a>) list<br>       | `String of string ]</code> </pre>


<pre><span id="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type"><a href="OpamJson.html#TYPEt">t</a> -> string</code></pre>
<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type"><a href="OpamJson.html#TYPEt">t</a> -> unit</code></pre>
<pre><span id="VALoutput"><span class="keyword">val</span> output</span> : <code class="type">unit -> unit</code></pre>
<pre><span id="VALset_output"><span class="keyword">val</span> set_output</span> : <code class="type">(string -> unit) -> unit</code></pre>
<pre><span id="VALverbose"><span class="keyword">val</span> verbose</span> : <code class="type">unit -> bool</code></pre></body></html>